***************
Pelicans On AWS
***************

:date: 2020-12-02 00:00
:modified: 2020-12-02 00:00
:tags: Web
:category: Web Development
:authors: Adams Rosales
:summary: How I develop and host this site
:header_cover: /static/post2/header.jpg

Huh?
####
This is a post about how I created this site (so meta). I used a Python framework called Pelican for developing static
websites and hosted it behind a CloudFront CDN on S3. I don't think I've ever actually had fun deploying any web
anything until now so I figured it's a good topic to discuss!

Architecture
############
In case you're not familiar with the phrase, a static website is simply a site that consists of files that are served
directly to the users of the site. There is no need to make request to backend servers for any sort of data like you
have with dynamic websites. Sites that lend themselves to static architectures are simple blogs, portfolios, small
business sites, etc. that don't require the user to interact with any service or dynamic functionality other than what
can be done with simple JS on the client-side. This makes things a lot easier because all you really need to do is write
the HTML/CSS and save it somewhere that's accessible from the Internet and voila you have a website.

An obvious location to save these static files is `S3 <https://aws.amazon.com/s3/>`_. You can store anything you want
for cheap and use what you store with all other AWS services that enable you to deploy highly scalable websites without
writing complex code and managing servers yourselves. I found it easy to quickly set up a DNS name, load balancer,
SSL certificate, and CDN without worrying about all the complexities. This architecture is diagrammed below:

.. image:: /static/post2/post2_architecture.jpeg
  :width: 80%
  :alt: https://aws.amazon.com/blogs/security/how-to-protect-your-web-application-against-ddos-attacks-by-using-amazon-route-53-and-a-content-delivery-network/

Client requests for the different domain records associated with decipheringbigdata.net in the hosted zone get routed
to the CDN DNS for the different files available in S3. The files in S3 are only exposed via the CDN (CloudFront), which
efficiently delivers them to clients depending on where they are in the World. All I need to do is deploy the site's
files to the S3 bucket behind the CDN and they will automatically be served to users that visit decipheringbigdata.net.

The site's HTTPS certificate was generated by `Certificate Manager <https://aws.amazon.com/certificate-manager/>`_ and
associated with the decipheringbigdata.net domain which was registered with `Route 53 <https://aws.amazon.com/route53/>`_.

Below is the CloudFormation template that deploys this architecture to AWS.

.. code-block:: yaml

    AWSTemplateFormatVersion: 2010-09-09
    Description: S3 / Route53 / CloudFront CloudFormation configuration

    Parameters:
      # SSL certificate created by CertificateManager
      AwsCertificateArn:
        Type:         String
        Default:      arn:aws:acm:us-east-1:146066720211:certificate/c681b862-cbdc-4d52-9029-13cc15a4c87f
        Description:  Certificate must be created before CloudFormation stack so the value is fixed
      AwsRoute53CloudFrontHostedZoneId:
        Type:         String
        Default:      Z2FDTNDATAQYW2
        Description:  CloudFront resources HostedZoneId
      # decipheringbigdata.net
      RootDomainName:
        Description: Domain name for your website (example.com)
        Type: String

    Resources:
      # Identity to use in CDN
      DataBlogCloudFrontIdentity:
        Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
        Properties:
          CloudFrontOriginAccessIdentityConfig:
            Comment: "Decipheringbigdata Origin Access Identity"

      # Where to store the actual website files
      DataBlogS3Bucket:
        Type: AWS::S3::Bucket
        Properties:
          BucketName: !Ref RootDomainName

      # CDN distribution of the files in the S3 bucket above
      DataBlogCloudFront:
        Type: "AWS::CloudFront::Distribution"
        Properties:
          DistributionConfig:
            Aliases:
              - !Ref RootDomainName
            Comment: !Ref RootDomainName
            DefaultCacheBehavior:
              AllowedMethods:
                - GET
                - HEAD
              CachedMethods:
                - GET
                - HEAD
              ForwardedValues:
                QueryString: True
              TargetOriginId:
                !Join ["", ["S3-origin-", !Ref RootDomainName]]
              ViewerProtocolPolicy: redirect-to-https
            DefaultRootObject: index.html
            Enabled: True
            HttpVersion: http2
            IPV6Enabled: True
            Origins:
              - DomainName: !GetAtt DataBlogS3Bucket.RegionalDomainName
                Id: !Join ["", ["S3-origin-", !Ref RootDomainName]]
                S3OriginConfig:
                  OriginAccessIdentity: !Sub "origin-access-identity/cloudfront/${DataBlogCloudFrontIdentity}"
            PriceClass: PriceClass_All
            ViewerCertificate:
              AcmCertificateArn: !Ref AwsCertificateArn
              MinimumProtocolVersion: TLSv1.2_2018
              SslSupportMethod: sni-only

      # Allow access only by the CDN identity; no public access to the S3 files themselves is allowed
      DataBlogS3BucketPolicy:
        Type: AWS::S3::BucketPolicy
        Properties:
          Bucket: !Ref DataBlogS3Bucket
          PolicyDocument:
            Statement:
              - Action:
                  - "s3:GetObject"
                Effect: Allow
                Principal:
                  AWS:
                    !Join [
                      "",
                      [
                        "arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ",
                        !Ref DataBlogCloudFrontIdentity,
                      ],
                    ]
                Resource: !Join ["", ["arn:aws:s3:::", !Ref DataBlogS3Bucket, "/*"]]
            Version: "2012-10-17"

      # How to redirect requests to decipheringbigdata.net to the CDN
      DataBlogRoute53:
        Type: AWS::Route53::RecordSet
        Properties:
          AliasTarget:
            DNSName: !GetAtt DataBlogCloudFront.DomainName
            EvaluateTargetHealth: False
            HostedZoneId: !Ref AwsRoute53CloudFrontHostedZoneId
          Comment: !Ref RootDomainName
          HostedZoneName: !Sub '${RootDomainName}.'
          Name: !Ref RootDomainName
          Type: A

    Outputs:
      Route53URL:
        Value:        !Ref DataBlogRoute53
        Description:  "DataBlog URL"
      CloudFrontURL:
        Value:        !GetAtt DataBlogCloudFront.DomainName
        Description:  "DataBlogCloudFront URL"


The Pelican
###########
One of the advantages of dynamic sites is that you can use the web application frameworks to serve HTML in a reusable
format with the help of templating engines like Jinja. Frameworks like Node.js, Django, and Flask all have this ability
and make it easy to manage the different resources associated with sites in distributable software packages.
When I switched over to a static site implementation of this blog I went searching for a way to seamlessly make
formatting changes to all of the static files in S3 and deploy them without breaking a sweat like I was used to with
these types of dynamic web application frameworks.

Alas, I came across this amazing Python framework for static website generation called `Pelican <https://blog.getpelican.com/>`_.
I'm in love with this thing! It makes producing content for static sites a breeze.

The basic gist is that you can write your content in a predefined location with easy to read Markdown or reStructuredText
and provide your settings in a config file using native Python. Pelican will then wrap up your little precious site baby
and deliver it seamlessly to its destination with all of its necessary static, CSS, and HTML files. You can also plug in
various `themes from open source contributions  <http://www.pelicanthemes.com/>`_ without having to mess with the CSS or
Bootstrap idioms in the HTML.

To see it in action, you can set up a quickstart site yourself as documented `here <https://opensource.com/article/19/1/getting-started-pelican>`_
and below:

1. Install Pelican in a Python virtual environment

.. code-block:: bash

    python3 -m venv venv
    ./venv/bin/pip install --upgrade pip
    ./venv/bin/pip install pelican

2. Create a Hello World site and skeleton code to get started

.. code-block:: bash

    ./venv/bin/pelican-quickstart

3. Fill out the form like I have done so below

.. image:: /static/post2/post2_pelicansetup.jpeg
  :width: 80%
  :alt: Running ./venv/bin/pelican-quickstart for decipheringbigdata.net


4. Start a local dev server and preview the site at http://localhost:8000

.. code-block:: bash

    source venv/bin/activate
    make devserver

5. Deploy to S3

.. code-block:: bash

    source venv/bin/activate
    make s3_upload

To make additions to your site you can edit the different configuration in the pelicanconf.py file and add .rst or .md
content files to your content directory. As mentioned before you can also leverage a suite of themes built by the
open source community as documented in `this  <https://github.com/getpelican/pelican-themes/>`_ Github repo. For
decipheringbigdata.net I have used the `clean-blog theme  <https://github.com/gilsondev/pelican-clean-blog/>`_.

When you deploy to S3 using the Makefile that the quickstart setup provides with the basic site, Pelican will bundle
up the generated output directory and copy it to the S3 bucket you specify. This should be the bucket that you've set
up the AWS static site infrastructure with.

That's it! End-to-end creation of static content and deployment to a scalable web infrastructure using Pelican and AWS.
If you're curious, you can checkout my `Github repo for decipheringbigdata.com  <https://github.com/adaros92/data-blog/>`_
to see the full code. Enjoy!