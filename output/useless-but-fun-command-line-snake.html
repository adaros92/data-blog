<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="https://decipheringbigdata.com/theme/css/style.css">
	<!--<link rel="stylesheet/less" type="text/css" href="/theme/css/style.less">-->
	<!--<script src="/theme/js/less.js" type="text/javascript"></script>-->
	<link rel="stylesheet" type="text/css" href="https://decipheringbigdata.com/theme/css/pygments.css">
	<link href='//fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>



		<title>Deciphering Big Data</title>
		<meta charset="utf-8" />

	<script>
  (function (s, e, n, d, er) {
    s['Sender'] = er;
    s[er] = s[er] || function () {
      (s[er].q = s[er].q || []).push(arguments)
    }, s[er].l = 1 * new Date();
    var a = e.createElement(n),
        m = e.getElementsByTagName(n)[0];
    a.async = 1;
    a.src = d;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://cdn.sender.net/accounts_resources/universal.js', 'sender');
  sender('b39da685833967')
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154188882-2">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154188882-2');
</script>
</head>
<body>
	<section id="sidebar">
		<figure id="user_logo">
            <a href="https://decipheringbigdata.com"><div class="logo">&nbsp;</div></a>
		</figure>

		<div class="user_meta">
            <h1 id="user"><a href="https://decipheringbigdata.com" class="">Adams Rosales</a></h1>
			<h2></h2>
			<p class="bio">has some opinions about data engineering</p>
			<ul>
					<a href="https://decipheringbigdata.com/pages/about-me.html">About Me</a><br><br>
					<a href="https://www.linkedin.com/in/adamsr09/">LinkedIn</a>
			</ul>
		</div>
		<footer>
			<address>
				Powered by <a href="https://blog.getpelican.com/">Pelican</a>
			</address>
		</footer>
	</section>

	<section id="posts">
	<header>
		<h1>Adams Rosales's blog</h1>
		<h3>Posted Dec 14, 2020</h3>
	</header>
	<article>
		<h1 id="title">
			<a href="https://decipheringbigdata.com/useless-but-fun-command-line-snake.html" rel="bookmark"
				title="Permalink to Useless but Fun: Command Line Snake">Useless but Fun: Command Line Snake</a>
		</h1>
		<div class="section" id="design">
<h2>Design</h2>
<p>Nobody: ...</p>
<p>Me on a Sunday night: I think I'll build a command line Snake game.</p>
<p>What does this have to do with big data? Probably nothing but the heart wants what it wants. Let's get started!</p>
<p>In usual object-oriented fashion, we'll have the following classes.</p>
<ul class="simple">
<li>Game - contains the game loop and manages interactions between the objects involved in the game</li>
<li>Snake - represents the actual Snake by managing its movement and eating functionality</li>
<li>Board - contains the state of the Snake grid (location of the snake and food items)</li>
<li>Player - represents the single Snake player by handling key events</li>
<li>Food - little yummy bits that the snake eats to grow</li>
</ul>
</div>
<div class="section" id="snake-implementation">
<h2>Snake Implementation</h2>
<p>I have chosen Python as the programming language because the python is a type of snake. There are many kinds of python -
ball python, Burmese python, Borneo python, Timor python...the list goes on.</p>
<p>Anyway let's start by implementing the ssssnake itself.</p>
<img alt="I'm a ssssnake" src="https://media.giphy.com/media/sjr7k1uuO0B0c/giphy.gif" style="width: 50%;" />
<p>When the snake moves, different segments of its body can be moving in different directions (left, up, right, or down)
on the grid. Representing the snake as a linked list will allow us to manage the snake as a collection of individual
nodes where each node encapsulates information about its coordinates on the grid and direction of movement.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot; Represents each node in the body of the snake &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">next_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prev_node</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">x_coordinate</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">y_coordinate</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">representation</span> <span class="o">=</span> <span class="n">representation</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">next_node</span> <span class="o">=</span> <span class="n">next_node</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">prev_node</span> <span class="o">=</span> <span class="n">prev_node</span>

<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation</span>

<span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</pre></div>
<p>Cool, we have a way to keep some state about each individual component of the snake's body. Now let's implement the
body of the snake.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Body</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot; Represents the body of the snake; Defines common functionality for growing and moving &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">x_coordinate</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">y_coordinate</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="c1"># Grow the body to the desired initial length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grow</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="n">coordinates_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tmp_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">tmp_node</span><span class="p">:</span>
        <span class="n">coordinates_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tmp_node</span><span class="o">.</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">tmp_node</span><span class="o">.</span><span class="n">y_coordinate</span><span class="p">))</span>
        <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">tmp_node</span><span class="o">.</span><span class="n">next_node</span>
    <span class="k">return</span> <span class="n">coordinates_list</span>

<span class="k">def</span> <span class="nf">change_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Changes the current body&#39;s direction of movement</span>
<span class="sd">    :param new_direction - one of four possible directions to move the body in</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opposite_direction</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span> <span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span> <span class="s2">&quot;down&quot;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">]</span>
    <span class="c1"># Only change the current direction if it&#39;s not opposite of the current direction</span>
    <span class="k">if</span> <span class="n">new_direction</span> <span class="o">!=</span> <span class="n">opposite_direction</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">new_direction</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">_create_new_node</span><span class="p">(</span><span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="n">x_coordinate</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">y_coordinate</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
        <span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">y_coordinate</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
        <span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">y_coordinate</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
        <span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">x_coordinate</span>
        <span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
        <span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">x_coordinate</span>
        <span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">prev_node</span><span class="o">=</span><span class="n">prev_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_node</span>

<span class="k">def</span> <span class="nf">grow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Grows the current body by the specified amount of nodes</span>
<span class="sd">    :param by - the number of nodes to grow the body by</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">by</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">new_node_chain</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">last_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Create a new chain of nodes to append to the end of the body</span>
    <span class="k">for</span> <span class="n">new_node_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">by</span><span class="p">):</span>
        <span class="c1"># Create the first node in the chain</span>
        <span class="k">if</span> <span class="n">new_node_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_node_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_node</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">prev_node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">new_node_chain</span>
        <span class="c1"># Create all the other nodes after the first one and add them to the chain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_node</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">last_node</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">prev_node</span><span class="o">=</span><span class="n">last_node</span><span class="p">)</span>
            <span class="n">last_node</span><span class="o">.</span><span class="n">next_node</span> <span class="o">=</span> <span class="n">tmp_node</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">tmp_node</span>
    <span class="c1"># Integrate the new chain as part of the current body</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">next_node</span> <span class="o">=</span> <span class="n">new_node_chain</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">last_node</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">by</span>

<span class="k">def</span> <span class="nf">slither</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Moves the body in its current direction of movement</span>
<span class="sd">    :param speed - the speed to move the body in</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Each node will assign its direction and coordinate to the next node</span>
    <span class="n">tmp_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next_node</span>
    <span class="n">tmp_x_coordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">x_coordinate</span>
    <span class="n">tmp_y_coordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">y_coordinate</span>
    <span class="k">while</span> <span class="n">tmp_node</span><span class="p">:</span>
        <span class="n">new_x_coordinate</span> <span class="o">=</span> <span class="n">tmp_node</span><span class="o">.</span><span class="n">x_coordinate</span>
        <span class="n">new_y_coordinate</span> <span class="o">=</span> <span class="n">tmp_node</span><span class="o">.</span><span class="n">y_coordinate</span>
        <span class="n">tmp_node</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">tmp_x_coordinate</span>
        <span class="n">tmp_node</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">tmp_y_coordinate</span>
        <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">tmp_node</span><span class="o">.</span><span class="n">next_node</span>
        <span class="n">tmp_x_coordinate</span> <span class="o">=</span> <span class="n">new_x_coordinate</span>
        <span class="n">tmp_y_coordinate</span> <span class="o">=</span> <span class="n">new_y_coordinate</span>
    <span class="c1"># Once all other nodes have moved, the head moves to new location</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">movement</span><span class="o">.</span><span class="n">resolve_movement</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">y_coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">node_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tmp_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">tmp_node</span><span class="p">:</span>
        <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tmp_node</span><span class="p">))</span>
        <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">tmp_node</span><span class="o">.</span><span class="n">next_node</span>
    <span class="k">return</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>

<span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</pre></div>
<p>This just takes a starting location for the head of the snake and direction of movement. It implements the core methods
of eating/growing and moving.</p>
<p>We will emulate movement with the slither method as follows:</p>
<ol class="arabic simple">
<li>Iterate over each node in the snake</li>
<li>Get the previous node's coordinates and direction of movement and assign them to the current node</li>
<li>Move the head of the snake to a new coordinate based on the direction of movement</li>
</ol>
<p>The last step of assigning a new coordinate to the head based on the direction of movement is implemented with the following
utility function.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">resolve_movement</span><span class="p">(</span><span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot; Given current coordinates and a movement around a 2D grid, this function will return new coordinates that</span>
<span class="sd">reflect that movement in 2 dimensional space</span>
<span class="sd">:param x_coordinate - x-coordinate identifying the starting point on a 2D grid</span>
<span class="sd">:param y_coordinate - y-coordinate identifying the starting point on a 2D grid</span>
<span class="sd">:param direction - one of four possible directions to move in</span>
<span class="sd">:returns a tuple of integers representing a new point (x-coordinate, y-coordinate)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">}</span>
<span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x_coordinate</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_coordinate</span>
<span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x_coordinate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_coordinate</span>
</pre></div>
<p>The body's grow method simply creates a given number of new node and appends it to the end of the linked list. This
method will be called whenever the snake eats a tasty boi on the grid.</p>
<p>Finally there is the Snake class itself which implements a higher level API that the game will communicate with. This
includes methods for eating and moving. The snake class will manage its body accordingly when these methods are called.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Snake</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot; Represents the snake itself</span>
<span class="sd">Constructor arguments:</span>
<span class="sd">:param x_coordinate - the starting x-coordinate of the snake&#39;s head</span>
<span class="sd">:param y_coordinate - the starting y-coordinate of the snake&#39;s head</span>
<span class="sd">:param starting_length - the snake&#39;s starting node length</span>
<span class="sd">:param starting_direction - the starting direction of movement that the snake will immediately head in</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="n">starting_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">starting_direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">Body</span><span class="p">(</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">starting_length</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">starting_direction</span><span class="p">)</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">current_location</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Retrieves a list of coordinate tuples representing the snake&#39;s location on a snake grid</span>
<span class="sd">    Example: [(0,1), (1,1)] is a 2 node long snake and on a 3 x 3 grid will look like this:</span>
<span class="sd">    _ _ _</span>
<span class="sd">    * * _</span>
<span class="sd">    _ _ _</span>
<span class="sd">    :returns a list of coordinate tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">coordinates</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">current_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Retrieves the snake&#39;s current direction of movement</span>
<span class="sd">    :returns a direction string (left, up, right, down)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">direction</span>

<span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food_to_eat</span><span class="p">:</span> <span class="nb">any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Eats a given food and makes the snake grow by the food&#39;s growth value</span>
<span class="sd">    :param food_to_eat - a food object as defined in food.py</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">grow</span><span class="p">(</span><span class="n">food_to_eat</span><span class="o">.</span><span class="n">growth_value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Moves the snake by changing the direction to the new direction and altering the corresponding</span>
<span class="sd">    coordinates based on that direction of movement</span>
<span class="sd">    :param new_direction - the direction of movement (left, up, right, down)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Change direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">change_direction</span><span class="p">(</span><span class="n">new_direction</span><span class="p">)</span>
    <span class="c1"># Move</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">slither</span><span class="p">()</span>

<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

<span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="player-implementation">
<h2>Player Implementation</h2>
<p>The player in the game of Snake just presses up, down, left, and right arrow keys on their keyboard to move the snake.
We can implement that by adding a listener that runs in a separate thread which will populate a queue with key presses.
Back in the original game thread, we will keep the state of the last key that was pressed in a map of key name to a
pressed boolean. Whenever a new event comes through the status will be updated for the corresponding key in the map.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="kn">from</span> <span class="nn">curtsies</span> <span class="kn">import</span> <span class="n">Input</span>


<span class="k">class</span> <span class="nc">Player</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">player_id</span><span class="p">:</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">(),</span> <span class="n">computer</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">player_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">player_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished_game</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computer</span> <span class="o">=</span> <span class="n">computer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;up&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&lt;UP&gt;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&lt;RIGHT&gt;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&lt;LEFT&gt;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&lt;DOWN&gt;&#39;&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_to_key_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_pressed_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monitoring_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_detect_key_pressed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Detects presses of individual keys and marks those keys as pressed in common object &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Check to see if any keys have been pressed</span>
            <span class="k">with</span> <span class="n">Input</span><span class="p">(</span><span class="n">keynames</span><span class="o">=</span><span class="s1">&#39;curtsies&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">input_generator</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">input_generator</span><span class="p">:</span>
                    <span class="c1"># Iterate over the applicable keys the player can press</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_to_key_map</span><span class="p">:</span>
                        <span class="n">pretty_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_to_key_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                        <span class="c1"># If the player has pressed a key that is being tracked</span>
                        <span class="k">if</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                            <span class="c1"># Signal that the key has been pressed in common object</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">key_pressed_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_pressed_map</span><span class="p">}</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">key_pressed_map</span><span class="p">[</span><span class="n">pretty_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished_game</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">monitor_key_presses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;thread&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;thread&quot;</span><span class="p">,</span> <span class="s2">&quot;block&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;block&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A keyboard key name must be provided to block until key is pressed&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;thread&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_detect_key_pressed</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="c1"># TODO blocking key press</span>

    <span class="k">def</span> <span class="nf">wait_for_player_to_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
<p>Here I'm using the Input class from the curtsies library which handles the event listening for me. The _detect_key_pressed
method will simply iterate over each generated key and update the map of pressed keys. It will always update the map with
the last key pressed only. There cannot be multiple keys pressed at one time since that doesn't make sense in the context
of snake.</p>
<p>The monitor_key_presses method just launches a new thread that runs the _detect_key_pressed method. The thread here is
not an actual thread because of the GIL (check out my <a class="reference external" href="https://decipheringbigdata.com/python-parallelism.html">previous post</a>)
but it works well enough for our purposes.</p>
</div>
<div class="section" id="food-implementation">
<h2>Food Implementation</h2>
<p>This will consist of two types of classes - individual food objects and a collection of food objects to generate them
at random.</p>
<p>First up we have the abstract food class. This just defines an interface that all food classes should abide by. In each
one of these we'll collect the coordinates where they are on the grid, how to represent the food objects in the terminal,
and each food type's nutritional value.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">pygme.utils</span> <span class="kn">import</span> <span class="n">space</span>


<span class="k">class</span> <span class="nc">Food</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents snake food by keeping track of each food object&#39;s location on a Snake grid, its character</span>
<span class="sd">    representation in the game (how it&#39;s shown to the user on the grid), and whether the food object has been eaten</span>
<span class="sd">    or not.</span>
<span class="sd">    This class defines a common interface for different types of concrete food classes.</span>
<span class="sd">    Constructor arguments:</span>
<span class="sd">    :param food_type - the type of food</span>
<span class="sd">    :param representation - a string representation of the given type of food</span>
<span class="sd">    :param x_coordinate - the x-coordinate of the food&#39;s location on the grid</span>
<span class="sd">    :param y_coordinate - the y-coordinate of the food&#39;s location on the grid</span>
<span class="sd">    :param food_id - a unique ID that identifies the food object (generated by default)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">food_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">food_id</span><span class="p">:</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">food_type</span> <span class="o">=</span> <span class="n">food_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">representation</span> <span class="o">=</span> <span class="n">representation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">food_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">food_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">=</span> <span class="n">x_coordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">y_coordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eaten</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Retrieves the food&#39;s location on the grid</span>
<span class="sd">        :returns a tuple of point coordinates (x-coordinate, y-coordinate)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_coordinate</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">growth_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Defines how much consumers of the food grow by after eating it which will depend on the subclass &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; repr() on food objects will resolve to the given string representation of each food &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; str() on food objects will resolve to the given string representation of each food  &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Two food objects are equal if their type, unique_id, and representation are the same</span>
<span class="sd">        :param other - a different Food object</span>
<span class="sd">        :returns true if the foods are the same, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">food_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">food_type</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">food_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">food_id</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">representation</span><span class="p">)</span>
</pre></div>
<p>I got lazy here and just created two types of food - crickets and mice. Each generates a random value to grow the snake
by. The mouse is obviously the most nutritious for the snake (do snakes even eat crickets?).</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cricket</span><span class="p">(</span><span class="n">Food</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents the cricket type of snake food which is the most common of the types and provides the least</span>
<span class="sd">    amount of nutritional value for snakes</span>
<span class="sd">    Class attributes:</span>
<span class="sd">    SPAWN_WEIGHT - defines the relative frequency that crickets spawn with</span>
<span class="sd">    Constructor arguments:</span>
<span class="sd">    :param representation - a string representation for how to show crickets on the snake grid</span>
<span class="sd">    :param x_coordinate - the x-coordinate of the food&#39;s location on the grid</span>
<span class="sd">    :param y_coordinate - the y-coordinate of the food&#39;s location on the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SPAWN_WEIGHT</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">food_type</span><span class="o">=</span><span class="s2">&quot;crickets&quot;</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="o">=</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="o">=</span><span class="n">y_coordinate</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">growth_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Defines by how many nodes the snake grows when it consumes a cricket</span>
<span class="sd">        :returns a random number of nodes the snake will grow by if it eats a cricket</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Mouse</span><span class="p">(</span><span class="n">Food</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents the mouse type of snake food which is the least common of the foods and provides the most</span>
<span class="sd">    nutritional value</span>
<span class="sd">    Class attributes:</span>
<span class="sd">    SPAWN_WEIGHT - defines the relative frequency that mice spawn with</span>
<span class="sd">    Constructor arguments:</span>
<span class="sd">    :param representation - a string representation for how to show mice on the snake grid</span>
<span class="sd">    :param x_coordinate - the x-coordinate of the food&#39;s location on the grid</span>
<span class="sd">    :param y_coordinate - the y-coordinate of the food&#39;s location on the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SPAWN_WEIGHT</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">food_type</span><span class="o">=</span><span class="s2">&quot;mouse&quot;</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="o">=</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="o">=</span><span class="n">y_coordinate</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">growth_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Defines by how many nodes the snake grows when it consumes a mouse</span>
<span class="sd">        :returns a random number of nodes the snake will grow by if it eats a mouse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>The food collection inherits from the native Python list and acts like a queue. the _refresh method updates the queue
with new food objects from the available types. These will be randomly spawned based on their SPAWN_WEIGHT class
attributes. The generate method will simply pop food objects from the front of the queue until it reaches the end. It
will then call _refresh to repopulate the queue with new food objects. It will act like an endless generator of random
food spawns for as long as the generate method of a FoodCollection instance keeps getting called.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FoodCollection</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Keeps a collection of different types of food objects to be used as a queue by a Snake game for randomly</span>
<span class="sd">    generating food objects on the grid</span>
<span class="sd">    Constructor arguments:</span>
<span class="sd">    :param grid_width - the width of the grid used by the snake game to generate food objects in</span>
<span class="sd">    :param grid_length - the length of the grid used by the snake game to generate food objects in</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_width</span> <span class="o">=</span> <span class="n">grid_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_length</span> <span class="o">=</span> <span class="n">grid_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Retrieves the max length of the food collection based on the size of the grid the collection is used</span>
<span class="sd">        to support with random food spawns</span>
<span class="sd">        :returns an integer with the max number of food objects the collection can have at any time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_length</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Resets the current collection by emptying it and making room for new food objects up to the max length</span>
<span class="sd">        allowed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Empty the current food collection</span>
        <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create space for populating it with new food items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>

    <span class="k">def</span> <span class="nf">_refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Provides a new bash of food objects in the current food collection based on how often each food</span>
<span class="sd">        object should appear when chosen randomly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Empty the collection and make room for new food objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>
        <span class="c1"># Enumerate the types of food to choose from and their relative weights of appearance frequency</span>
        <span class="n">eligible_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mouse</span><span class="p">,</span> <span class="n">Cricket</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mouse</span><span class="o">.</span><span class="n">SPAWN_WEIGHT</span><span class="p">,</span> <span class="n">Cricket</span><span class="o">.</span><span class="n">SPAWN_WEIGHT</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eligible_types</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="c1"># Generate max_length number of food objects randomly in a stratified fashion based on their weights</span>
        <span class="n">random_type_choices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">eligible_types</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">food_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">random_type_choices</span><span class="p">):</span>
            <span class="c1"># Assign random coordinates to each food item for the game to use for grid placement</span>
            <span class="n">random_coordinates</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">get_coordinates_between_limits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_length</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">food_type</span><span class="p">(</span><span class="n">x_coordinate</span><span class="o">=</span><span class="n">random_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_coordinate</span><span class="o">=</span><span class="n">random_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates the given count of random food objects from the collection and refreshes the collection</span>
<span class="sd">        with new objects if the collection is empty</span>
<span class="sd">        :param count - the number of food objects to generate</span>
<span class="sd">        :returns a list of randomly chosen food objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">return_foods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="c1"># Refresh the current collection with new food objects if the collection is empty</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_refresh</span><span class="p">()</span>
            <span class="c1"># Get last object from the food collection and remove it from the collection</span>
            <span class="n">return_foods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">return_foods</span>
</pre></div>
<p>The utility function, get_coordinates_between_limits, just returns random coordinates that lie within the limits of a
2D grid. This is called in the _refresh method when instantiating new food objects and assigning them random coordinates
on the grid.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_coordinates_between_limits</span><span class="p">(</span><span class="n">grid_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Provides random coordinates between the specified limits on a 2D grid</span>
<span class="sd">    :param grid_width - the width of the grid in number of squares</span>
<span class="sd">    :param grid_length - the length of the grid in number of squares</span>
<span class="sd">    :returns a tuple with (x-coordinate, y-coordinate)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random_x_coordinate</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">random_y_coordinate</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">random_x_coordinate</span><span class="p">,</span> <span class="n">random_y_coordinate</span>
</pre></div>
</div>
<div class="section" id="board-implementation">
<h2>Board Implementation</h2>
<p>Now we implement the board where all the action will take place. The snake will move around the board eating snacks until
it bumps into one of the walls and new food objects will randomly spawn. The board's job is just to accept coordinates
and representations of objects at those coordinates and print itself for the user.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pygme.utils.display</span> <span class="kn">import</span> <span class="n">clear_console</span>
<span class="kn">from</span> <span class="nn">pygme.utils.validation</span> <span class="kn">import</span> <span class="n">validate_grid_index</span>


<span class="k">class</span> <span class="nc">GameBoard</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents a base board to play a game on which may be extended by more specific types of boards</span>
<span class="sd">    Constructor arguments:</span>
<span class="sd">    :param length - the length of the board to create</span>
<span class="sd">    :param width - the width of the board to create</span>
<span class="sd">    :param empty_square - how to represent empty squares on the board</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">empty_square</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">empty_square</span> <span class="o">=</span> <span class="n">empty_square</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_board</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_square_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_square</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_create_board</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Creates an empty 2D list with the given board dimensions&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">empty_square</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Prints out the board to stdout &quot;&quot;&quot;</span>
        <span class="c1"># Clear the terminal</span>
        <span class="n">clear_console</span><span class="p">()</span>
        <span class="c1"># Print the current board</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">empty_square</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">square</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">square</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">square</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)]))</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Clears the current board by replacing every square with the given empty square character &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_square</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">clear_board</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Refreshes the board by adding the given representation character to the given coordinates</span>
<span class="sd">        Example: representation = &#39;*&#39; at coordinates [(0, 1), (2, 1)] on a 3x3 board will result in the following:</span>
<span class="sd">        _ _ _</span>
<span class="sd">        * _ *</span>
<span class="sd">        _ _ _</span>
<span class="sd">        :param coordinates - a list of coordinate tuples to update</span>
<span class="sd">        :param representation - the character to be placed in the given coordinates</span>
<span class="sd">        :param clear_board - whether to first clear the current board before placing the new characters or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear the current board first if the provided argument is true</span>
        <span class="k">if</span> <span class="n">clear_board</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">coordinate_tuple</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
            <span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span> <span class="o">=</span> <span class="n">coordinate_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coordinate_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Only refresh the board with the coordinate if the coordinate is valid</span>
            <span class="k">if</span> <span class="n">validate_grid_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">):</span>
                <span class="c1"># Refresh the board</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">x_coordinate</span><span class="p">][</span><span class="n">y_coordinate</span><span class="p">]</span> <span class="o">=</span> <span class="n">representation</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;GameBoard (</span><span class="si">{0}</span><span class="s2"> by </span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</pre></div>
<p>The core method here is refresh. This will take an input of coordinate tuples and add the given character representation
to each one of the squares defined by the coordinates on the board. It will clear itself each time the refresh method
is called unless told otherwise. Each time there is an update to the snake's location or a new food object spawns, the
refresh method will be called to print it in the terminal.</p>
<p>There are also a couple of utility functions being used here. The clear_console function will simply clear the contents
displayed on the user's terminal. This will be called each time the board is refreshed so that the game appears static
in the shell window.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear_console</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;nt&#39;</span> <span class="k">else</span> <span class="s1">&#39;clear&#39;</span><span class="p">)</span>
</pre></div>
<p>The validate_grid_index function is just used to ensure that updates only happen to coordinates that are within the
board.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_grid_index</span><span class="p">(</span><span class="n">grid_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
     <span class="k">if</span> <span class="n">x_coordinate</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x_coordinate</span> <span class="o">&gt;=</span> <span class="n">grid_length</span> <span class="ow">or</span> <span class="n">y_coordinate</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y_coordinate</span> <span class="o">&gt;=</span> <span class="n">grid_width</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">False</span>
     <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<div class="section" id="game-implementation">
<h2>Game Implementation</h2>
<p>Finally, the main game loop to tie all of the components above together.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">pygme.game.game</span> <span class="kn">import</span> <span class="n">Game</span>
<span class="kn">from</span> <span class="nn">pygme.game.player</span> <span class="kn">import</span> <span class="n">Player</span>
<span class="kn">from</span> <span class="nn">pygme.snake</span> <span class="kn">import</span> <span class="n">snake</span><span class="p">,</span> <span class="n">food</span>
<span class="kn">from</span> <span class="nn">pygme.utils.display</span> <span class="kn">import</span> <span class="n">clear_console</span>
<span class="kn">from</span> <span class="nn">pygme.utils.validation</span> <span class="kn">import</span> <span class="n">validate_user_input</span>


<span class="k">class</span> <span class="nc">SnakeGame</span><span class="p">(</span><span class="n">Game</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Defines the main Snake game loop and initialization functionality &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Snake&quot;</span><span class="p">,</span> <span class="n">number_of_players</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">difficulty</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">number_of_players</span><span class="p">,</span> <span class="n">difficulty</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">required_inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;board_width&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;board_length&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;difficulty&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snake</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">food_collection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_food</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">player</span> <span class="o">=</span> <span class="n">Player</span><span class="p">(</span><span class="n">computer</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialization_object</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Ensures that the given initialization_object containing parameters to run the Snake game has complete</span>
<span class="sd">        and valid parameters</span>
<span class="sd">        :param initialization_object - a dictionary containing game parameter names and their values for operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate completeness of inputs</span>
        <span class="k">for</span> <span class="n">required_input</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">required_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">required_input</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initialization_object</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> is a required input to begin a Snake game&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">required_input</span><span class="p">))</span>
        <span class="c1"># Validate correct board dimensions</span>
        <span class="n">board_width</span> <span class="o">=</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;board_width&quot;</span><span class="p">]</span>
        <span class="n">board_length</span> <span class="o">=</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;board_length&quot;</span><span class="p">]</span>
        <span class="n">difficulty</span> <span class="o">=</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;difficulty&quot;</span><span class="p">]</span>
        <span class="c1"># Required min coordinates for a game of snake</span>
        <span class="c1"># TODO should be in config</span>
        <span class="n">required_width</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">required_length</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;board_width&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">required_width</span> \
                <span class="ow">or</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;board_length&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">required_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Snake board must be at least </span><span class="si">{0}</span><span class="s2">x</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">required_length</span><span class="p">,</span> <span class="n">required_width</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">board_width</span> <span class="o">!=</span> <span class="n">board_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Snake board must be a square where width == length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">difficulty</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIFFICULTY_TYPES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The game difficulty must be one of </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIFFICULTY_TYPES</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialization_object</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Initializes a game of Snake from the given object of game parameters or user input if one is not provided</span>
<span class="sd">        :param initialization_object - a dictionary containing game parameter names and their values for operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get input from the user if no initialization_object is provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">initialization_object</span><span class="p">:</span>
            <span class="n">initialization_object</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">pre_prompt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">clear_console</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">Provide your inputs to begin your game of Snake. Difficulty levels: easy, normal, hard</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pre_prompt</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">required_input</span><span class="p">,</span> <span class="n">input_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">required_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">input_val</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter a value for </span><span class="si">{0}</span><span class="s2">: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">required_input</span><span class="p">))</span>
                        <span class="n">initialization_object</span><span class="p">[</span><span class="n">required_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">validate_user_input</span><span class="p">(</span>
                            <span class="n">required_input</span><span class="p">,</span> <span class="n">input_val</span><span class="p">,</span> <span class="n">input_type</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_validate_initialization</span><span class="p">(</span><span class="n">initialization_object</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">pre_prompt</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="k">pass</span>
        <span class="c1"># Validate the input passed through the method arguments</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_initialization</span><span class="p">(</span><span class="n">initialization_object</span><span class="p">)</span>
        <span class="c1"># Create the board</span>
        <span class="n">board_width</span> <span class="o">=</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;board_width&quot;</span><span class="p">]</span>
        <span class="n">board_length</span> <span class="o">=</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;board_length&quot;</span><span class="p">]</span>
        <span class="n">difficulty</span> <span class="o">=</span> <span class="n">initialization_object</span><span class="p">[</span><span class="s2">&quot;difficulty&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_board</span><span class="p">(</span><span class="n">board_length</span><span class="p">,</span> <span class="n">board_width</span><span class="p">)</span>
        <span class="c1"># Pick a random point to place the snake on and a starting snake length based on chosen difficulty</span>
        <span class="n">starting_x_coordinate</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">board_length</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">starting_y_coordinate</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">board_width</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">starting_length</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;easy&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;hard&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">}[</span><span class="n">difficulty</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snake</span> <span class="o">=</span> <span class="n">snake</span><span class="o">.</span><span class="n">Snake</span><span class="p">(</span>
            <span class="n">x_coordinate</span><span class="o">=</span><span class="n">starting_x_coordinate</span><span class="p">,</span> <span class="n">y_coordinate</span><span class="o">=</span><span class="n">starting_y_coordinate</span><span class="p">,</span> <span class="n">starting_length</span><span class="o">=</span><span class="n">starting_length</span><span class="p">)</span>
        <span class="c1"># Start monitoring player key presses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">player</span><span class="o">.</span><span class="n">monitor_key_presses</span><span class="p">()</span>
        <span class="c1"># Create a snake food collector and generator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">food_collection</span> <span class="o">=</span> <span class="n">food</span><span class="o">.</span><span class="n">FoodCollection</span><span class="p">(</span><span class="n">grid_width</span><span class="o">=</span><span class="n">board_width</span><span class="p">,</span> <span class="n">grid_length</span><span class="o">=</span><span class="n">board_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_game_over</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Checks the board to see if the game is over</span>
<span class="sd">        :returns True if the game is over, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">game_over</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">end_game_coordinates</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">current_snake_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">current_location</span>
        <span class="k">for</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="n">current_snake_location</span><span class="p">:</span>
            <span class="c1"># check if any coordinate is outside of the board</span>
            <span class="c1"># TODO: maybe only check if the head is outside for cases when snake grows into edge</span>
            <span class="k">if</span> <span class="n">coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">game_over</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">game_over</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            elif coordinate in end_game_coordinates:</span>
<span class="sd">                game_over = True</span>
<span class="sd">                break</span>
<span class="sd">            end_game_coordinates.add(coordinate)</span>
<span class="sd">            &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">game_over</span>

    <span class="k">def</span> <span class="nf">_get_food</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Randomly generates food into the current grid &quot;&quot;&quot;</span>
        <span class="c1"># TODO this should be in config</span>
        <span class="n">difficulty_to_frequency_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;normal&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;easy&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;hard&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="c1"># If there is any current food on the grid that is not eaten then just return and don&#39;t generate new food</span>
        <span class="k">for</span> <span class="n">current_food_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_food</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">current_food_obj</span><span class="o">.</span><span class="n">eaten</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="c1"># Randomly generate food based on frequency of appearance by difficulty level</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">difficulty_to_frequency_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">difficulty</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">generated_food_ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">generated_foods</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Keep generating until the food falls in a spot where it&#39;s ok</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">generated_food_ok</span><span class="p">:</span>
                <span class="n">generated_food_ok</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">generated_foods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">food_collection</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">generated_food</span> <span class="ow">in</span> <span class="n">generated_foods</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t place food in same place as Snake&#39;s head</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">generated_food</span><span class="o">.</span><span class="n">x_coordinate</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">current_location</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="ow">or</span> <span class="n">generated_food</span><span class="o">.</span><span class="n">y_coordinate</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">current_location</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="c1"># Regenerate if food is located at Snake&#39;s head</span>
                        <span class="n">generated_food_ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_food</span> <span class="o">=</span> <span class="n">generated_foods</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_food</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_resolve_food</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_snake_location</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Makes the snake eat the food and marks the food as eaten when that happens, which makes the object</span>
<span class="sd">        disappear from the grid; otherwise refresh the board with each uneaten piece of food</span>
<span class="sd">        :param current_snake_location - a list of current snake coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check each of the current food items on the grid</span>
        <span class="k">for</span> <span class="n">food_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_food</span><span class="p">:</span>
            <span class="c1"># If the snake&#39;s head is in the same square as the given food, then make the snake eat the food</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current_snake_location</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">food_obj</span><span class="o">.</span><span class="n">x_coordinate</span>
                    <span class="ow">and</span> <span class="n">current_snake_location</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">food_obj</span><span class="o">.</span><span class="n">y_coordinate</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">food_obj</span><span class="p">)</span>
                <span class="c1"># Marking the food object as eaten will make it disappear from the grid</span>
                <span class="n">food_obj</span><span class="o">.</span><span class="n">eaten</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># If the food still exists, show it again on the grid</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">food_obj</span><span class="o">.</span><span class="n">eaten</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">food_obj</span><span class="o">.</span><span class="n">x_coordinate</span><span class="p">,</span> <span class="n">food_obj</span><span class="o">.</span><span class="n">y_coordinate</span><span class="p">)],</span>
                    <span class="n">representation</span><span class="o">=</span><span class="n">food_obj</span><span class="o">.</span><span class="n">representation</span><span class="p">,</span>
                    <span class="n">clear_board</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_move_snake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_direction</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Moves the snake along the grid and checks for user input entered in separate thread</span>
<span class="sd">        :param current_direction - the direction the snake is current traveling in with respect to the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get directional input from the user about where to go</span>
        <span class="n">snake_direction</span> <span class="o">=</span> <span class="n">current_direction</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]:</span>
            <span class="c1"># Change direction only if there is a valid directional key event in the key press map</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">player</span><span class="o">.</span><span class="n">key_pressed_map</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">snake_direction</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">break</span>
        <span class="c1"># Move the snake in either the current or new direction depending on whether player pressed a key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">snake_direction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finish_game</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Game over! Hit &lt;Enter&gt; to play again or &lt;q&gt; to exit.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">player</span><span class="o">.</span><span class="n">finished_game</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">player</span><span class="o">.</span><span class="n">wait_for_player_to_finish</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialization_object</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Game loop that accepts player events to move the snake around the board and keeps the state of the game</span>
<span class="sd">        until the game finishes</span>
<span class="sd">        :param initialization_object - a dictionary containing game parameter names and their values for operation</span>
<span class="sd">        :returns a dictionary containing various metrics and their values about the game that was played</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">(</span><span class="n">initialization_object</span><span class="p">)</span>
        <span class="n">representation</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">current_snake_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">current_location</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_food</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="n">current_snake_location</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_food</span><span class="p">(</span><span class="n">current_snake_location</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Hit arrow keys on your keyboard to move the snake&quot;</span><span class="p">)</span>
            <span class="c1"># Get the current direction of the snake</span>
            <span class="n">snake_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="o">.</span><span class="n">current_direction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_move_snake</span><span class="p">(</span><span class="n">snake_direction</span><span class="p">)</span>
            <span class="n">game_over</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_game_over</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">game_over</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_finish_game</span><span class="p">()</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.25</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="section" id="the-final-game">
<h2>The Final Game</h2>
<p>Yup, one step closer to deciphering the secrets of big data.</p>
<img alt="Final game implementation" src="https://media.giphy.com/media/QLR9DHzeoqJgihomeM/giphy.gif" style="width: 75%;" />
<p>This is part of a Python package I'm working on called pygme (Like pygame but I dropped the a). I'm implementing common
games to play on your terminal. Check it out <a class="reference external" href="https://github.com/adaros92/pygme">here</a> if you're like me and have
nothing better to do with your time!</p>
</div>


		<div id="article_meta">
				Category:
					<a href="https://decipheringbigdata.com/category/programming.html">Programming</a>
				<br />Tags:
					<a href="https://decipheringbigdata.com/tag/programming.html">Programming</a>
		</div>
	</article>

	<footer>
		<a href="https://decipheringbigdata.com/" class="button_accent">&larr;&nbsp;&nbsp;&nbsp;Back to blog</a>
		<a id="emailSignup" class="button_accent">&nbsp;&nbsp;&nbsp;Sign up for our newsletter!</a>
	</footer>


	</section>

</body>
</html>